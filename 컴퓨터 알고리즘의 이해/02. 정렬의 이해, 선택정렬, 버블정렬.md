# 02. 정렬의 이해, 선택정렬, 버블정렬

- [정렬의 이해](#정렬의-이해)
- [선택정렬](#선택정렬)
- [버블정렬](#버블정렬)

## 정렬의 이해
- 레코드(정렬 대상 원소)들을 순서대로 재배치하는 일
- 정렬시간 = 레코드 접근 시간 + 레코드 비교/재배치 시간

### 정렬의 정류
**비교-기반 정렬 방식** : 선택정렬, 버블정렬, 삽입정렬, 쉘정렬, 퀵정렬, 합병정렬, 힙정렬
**분포-기반 정렬 방식** : 계수정렬, 기수정렬, 버킷정렬

### 성능 측정
**시간 복잡도**
- 비교-기반 : 키 비교기반 횟수
- 분포-기반 : 레코드의 이동 횟수
- 외부 정렬 : 외부 레코드 접근 횟수

**공간 복잡도**
- 대부분의 정렬은 빅오 1 혹은 빅오 n이라 시간복잡도 비교가 비슷함
- 제자리성 : 고정된 메모리인지, 입력에 따라 가변적인지

**안정성**
- 동일한 키값을 가지는 레코드들이 정렬 이후에도 동일한 위치에 위치하는지 (원래 순서를 유지하는지)
- 여러 알고리즘에 부분으로 들어가기 때문에 중요한 부분

## 선택정렬

### 코드와 이해
```c
void SelectionSort(int A[ ], int n)
/* 입력 : A[0:n－1] , n : 정렬할 원소의 개수.
출력 : A[0:n－1] : 정렬된 배열. */
{ int i, j, MinIndex;
    for (i ＝ 0; i ＜ n－1; i＋＋) {
        MinIndex＝ i;
        for (j＝MinIndex＋1; j＜n; j＋＋)
            if (A[MinIndex] ＞ A[j])
                MinIndex＝ j;
            if (MinIndex !＝ i)
        Swap(&A[i], &A[MinIndex]);
    }
}
```
- 
### 특징 정리
- i번째 단계에서 항상 n-i회 비교 수행
- **평균시간복잡도** = O(n^2)
- **최악시간복잡도** = O(n^2)
- **제자리성** : 제자리 정렬
    - `i`, `j`, `MinIndex` 등 상수 크기 메모리
- **안정성** : 불안정한 정렬
    - Ex. B b a c > a b B c
    - B로 비교를 할 때 B보다 작은 a와 바뀌며 a b B c가 됨
    - 동일한 키값을 가진 B b의 순서가 정렬중 바뀌므로 불안정
    - 2 2 1 3이라고 생각해도 됨


## 버블정렬

### 코드와 이해
```c
void BubbleSort0(int A[ ], int n)
/* 입력: A[0:n－1] , n : 정렬할 원소의 개수.
출력: A[0:n－1]: 정렬된 배열. */
{
    int i;
    for (i ＝ 1; i ＜ n; i＋＋)
        if (A[i－1] ＞ A[i])
            Swap(&A[i－1], &A[i]);
}
```
- `BubbleSort0` 함수를 정렬될 때까지 반복적용 시키면 됨
- 다만, 정렬을 하다 이미 정렬이 다 된 상태에서도 `BubbleSort0`은 마지막 단계까지 쭉 비교함
- 자리바꿈이 일어나지 않았다면 추후 단계를 생략하는 로직이 있으면 효율성 증가

```c
void BubbleSort(int A[ ], int n)
/* 입력: A[0:n－1] , n : 정렬할 원소의 개수.
출력: A[0:n－1]: 정렬된 배열. */
{
    int i, Sorted;
    Sorted ＝ FALSE;
    while (!Sorted) {
        Sorted ＝ TRUE;
        for (i ＝ 1; i ＜ n; i＋＋)
            if (A[i－1] ＞ A[i]) {
                Swap(&A[i－1], &A[i]);
                Sorted ＝ FALSE;
            }
    } 
}
```
- `Swap`이 일어나지 않으면 `Sorted`가 `TRUE`가 되어서 이후 자리바꿈을 생략함

### 특징 정리
- **평균시간복잡도** = O(n^2)
- **최악시간복잡도** = O(n^2)
    - 이미 역순정렬된 경우가 최악 케이스
    - 마지막 단계까지 `Sorted`가 `TRUE`가 되지 못하기 때문
- **제자리성** : 제자리 정렬
    - `i`, `Sorted` 등 상수 크기 메모리
- **안정성** : 안정된 정렬
    - 인접한 레코드끼리만 자리바꿈